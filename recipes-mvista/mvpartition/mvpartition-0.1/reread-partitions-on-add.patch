Modify the partitioner to re-scan the disks/RAIDS/LVMs upon adding partitions
instead of just adding the partition to the list.  This fixes problems
with RAIDs and LVMs that can be automatically added when creating a
partition with existing content, since any RAID or LVM will be automatically
added from the newly created partition, if it has RAID or LVM content.

This required some restructuring of the code, but the results are probably
better.

diff -r 6a2731e7f0a7 bin/mvpartition
--- a/bin/mvpartition	Thu Oct 14 17:46:43 2010 -0500
+++ b/bin/mvpartition	Wed Oct 27 17:03:47 2010 -0500
@@ -34,14 +34,9 @@
 input_fstab = "/etc/fstab"
 
 def run_partitioner(stdscr):
-    p = mvpartition.Partitioner.Partitioner(stdscr, output_fstab=output_fstab)
-    e = mvpartition.Partitioner._add_disks(p, input_fstab)
-    if (e):
-        p.popupWin(e)
-    else:
-        p.sc.refresh()
-        pass
-
+    p = mvpartition.Partitioner.Partitioner(stdscr,
+                                            input_fstab=input_fstab,
+                                            output_fstab=output_fstab)
     while (not p.done):
         c = stdscr.getch()
         p.handleCharRaw(c)
diff -r 6a2731e7f0a7 mvpartition/Partitioner.py
--- a/mvpartition/Partitioner.py	Thu Oct 14 17:46:43 2010 -0500
+++ b/mvpartition/Partitioner.py	Wed Oct 27 17:03:47 2010 -0500
@@ -36,6 +36,7 @@
 import copy
 import DebugLog
 import subprocess
+import tempfile
 
 import sys
 import traceback
@@ -277,7 +278,7 @@
         return
 
     def needsWork(self, p, device):
-        if (not self.name or not self.parent.changed):
+        if (not self.name or not self.parent.changed or p.in_reread):
             # Don't do the empty fstype or if unchanged
             return ()
         return (WorkObj(self, device, write_op=True), )
@@ -1458,49 +1459,42 @@
         kernel_update_worked = True
         if (extended):
             try:
-                num = _call_parted(self.partitiondevname,
-                                   ["mkpart extended %d %d"
-                                    % (o.sectstart,
-                                       o.sectstart + o.numsects - 1),])
+                _call_parted(self.partitiondevname,
+                             ["mkpart extended %d %d"
+                              % (o.sectstart,
+                                 o.sectstart + o.numsects - 1),])
             except CmdErr, e:
                 if ("Error informing the kernel" in e.out):
                     kernel_update_worked = False
-                    num = e.out
                 else:
                     raise
                 pass
-            lines = num.split("\n")
-            num = int(lines[len(lines)-2])
-            name = self.partitiondevname + self.namenumsep + str(num)
-            part = ExtendedPartition(p, self, name, num,
-                                     line + len(self.partitions) + 1,
-                                     o.sectstart, o.numsects)
-            self.partitionUpdatedHook(part, created=True)
         else:
             try:
-                num = _call_parted(self.partitiondevname,
-                                   ["mkpart %s %d %d"
-                                    % (self.subpartitions,
-                                       o.sectstart,
-                                       o.sectstart + o.numsects - 1),])
+                _call_parted(self.partitiondevname,
+                             ["mkpart %s %d %d"
+                              % (self.subpartitions,
+                                 o.sectstart,
+                                 o.sectstart + o.numsects - 1),])
             except CmdErr, e:
                 if ("Error informing the kernel" in e.out):
                     kernel_update_worked = False
-                    num = e.out
                 else:
                     raise
                 pass
-            else:
-                lines = num.split("\n")
-                num = int(lines[len(lines)-2])
-                pass
-            name = self.partitiondevname + self.namenumsep + str(num)
-            part = Partition(p, self, name, num,
-                             line + len(self.partitions) + 1,
-                             o.sectstart, o.numsects)
-            self.partitionUpdatedHook(part, created=True)
             pass
 
+        # We used to have parted return the added partition id (which
+        # itself required a hack, since for some odd reason parted
+        # didn't do this by default) and use that to add the proper
+        # information.  This had problems, though, since adding a
+        # partition with existing content could cause udev to
+        # instantiate RAIDs and LVMs, and the partitioner wouldn't
+        # know about this.  So to work around both of these problem,
+        # just reread everything when a partition is added.  It's
+        # slow, but it's reliable.
+        p.reRead()
+
         if (not kernel_update_worked):
             p.popupWin("Error informing the kernel about the partitions"
                        + " update for " + name + ", so linux will not"
@@ -2652,13 +2646,12 @@
 
 alldigits = ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9")
 
-def _read_fstab(t):
-    if (not t):
+def _read_fstab(f):
+    if (not f):
         return({}, [])
 
     info = {}
     extra = []
-    f = open(t)
     for l in f:
         s = l.strip()
         if (not s):
@@ -2686,14 +2679,7 @@
 
     p.popupInfo("Reading disk information, please wait")
 
-    try:
-        (fstab_info, fstab_extra) = _read_fstab(input_fstab)
-    except Exception, e:
-        startup_errs += ("Unable to open read fstab %s: %s"
-                           % (input_fstab, str(e)))
-        fstab_info = {}
-        fstab_extra = []
-        pass
+    (fstab_info, fstab_extra) = _read_fstab(input_fstab)
 
     # First look in /proc/diskstats and extract the disks.
     disks = []
@@ -2891,9 +2877,11 @@
 class Partitioner:
     done = False
     
-    def __init__(self, parent, output_fstab=None):
+    def __init__(self, parent, input_fstab=None, output_fstab=None):
         self.window = parent
 
+        self.in_reread = False
+
         self.output_fstab_str = output_fstab
         self.fstab_extra = [ ]
 
@@ -2911,16 +2899,13 @@
             pass
 
         (wheight, wwidth) = parent.getmaxyx()
-        fpheight = wheight - 4
-        self.nlines = fpheight
+        self.nlines = wheight - 4
         self.ncols = wwidth
-        if (fpheight < 5):
+        if (self.nlines < 5):
             raise PartitionerErr("Parent window height of %d is too small,"
                                  + "must be at least 5")
         self.header = parent.derwin(1, wwidth, 0, 0)
         self.footer = parent.derwin(1, wwidth, wheight - 1, 0)
-        self.sc = FlexScrollColumn.FlexScrollColumn(parent, fpheight, wwidth,
-                                                    2, 0)
         parent.hline(1, 0, '-', wwidth)
         parent.hline(wheight - 2, 0, '-', wwidth)
 
@@ -2931,12 +2916,42 @@
         self.header.refresh()
         self.footer.refresh()
 
+        self.popup = None
+
+        infstab = None
+        errs = ""
+        if (input_fstab):
+            try:
+                infstab = open(input_fstab)
+            except Exception, e:
+                errs = "Unable to process fstab %s: %s" % (input_fstab, str(e))
+                pass
+            pass
+        if (infstab):
+            infstab.close()
+            pass
+
         self.linepos = 0
         self.colpos = 0
-
+        errs += self.initInfo(infstab)
+        if (errs):
+            self.popupWin(errs)
+            pass
+        self.sc.refresh()
+        return
+
+    def initInfo(self, infstab):
+        old_linepos = self.linepos
         # A hash of line entries, indexed by id.
         self.ids = { }
 
+        self.linepos = 0
+        self.colpos = 0
+
+        self.sc = FlexScrollColumn.FlexScrollColumn(self.window,
+                                                    self.nlines, self.ncols,
+                                                    2, 0)
+
         self.disks = []
         self.diskObj = Label(self, "Disks")
         self.raids = []
@@ -2947,10 +2962,7 @@
         self.linepos = 0 # Messed up by the previous label adds
         self.sc.highlightColumn(self.linepos, self.colpos)
 
-        self.popup = None
-
-        self.sc.refresh()
-        return
+        return _add_disks(self, infstab)
 
     def setFstabExtra(self, l):
         self.fstab_extra = l
@@ -3104,6 +3116,55 @@
         self.header.refresh()
         return
 
+    def getWork(self):
+        work = ()
+        for i in range(0, self.numLines()):
+            o = self.getObj(i)
+            work = work + o.needsWork(self, o)
+            pass
+        return work
+        
+    def processWork(self, work, outfstab):
+        if outfstab:
+            self.output_fstab = outfstab
+            for l in self.fstab_extra:
+                self.output_fstab.write(l)
+                pass
+            pass
+        for w in work:
+            w.work(self)
+            pass
+        self.output_fstab = None
+        return
+
+    def reRead(self):
+        """Re-read information from the partition tables, RAIDS,and LVMs"""
+
+        # This keeps filesystems from being written.
+        self.in_reread = True
+        oldlinepos = self.linepos
+        oldcolpos = self.colpos
+
+        # First get our fstab information in a temp file.
+        work = self.getWork()
+        t = tempfile.TemporaryFile()
+        self.processWork(work, t)
+
+        # Flush the current contents and re-read the partitions using
+        # our saved fstab info.
+        
+        t.seek(0)
+        self.initInfo(t)
+
+        t.close()
+        self.in_reread = False
+
+        if (oldlinepos >= self.numLines()):
+            oldlinepos = self.numlines() - 1
+            pass
+        self.setPos(oldlinepos, oldcolpos)
+        return
+
     def _drawCurrInfo(self):
         s = "MontaVista Partition/RAID/LVM Manager"
         self.status_in_footer = False
@@ -3145,11 +3206,10 @@
             return
         
         if (c == 'Q'):
-            work = ()
-            for i in range(0, self.numLines()):
-                o = self.getObj(i)
-                work = work + o.needsWork(self, o)
-                pass
+            work = self.getWork()
+
+            # Do any of the work object write anything?  If so, query if
+            # the user really wants to do them.
             write_op = False
             for w in work:
                 if (w.write_op):
@@ -3178,9 +3238,7 @@
                     pass
                 pass
             pass
-            self.popupWin("Partition tables have been re-read, but you will"
-                          + " need to quit and restart the partitioner to"
-                          + " see the results of any changes.")
+            self.reRead()
         elif (c == '^L'):
             self.redraw()
         elif (c == '?'):
@@ -3256,17 +3314,13 @@
                             + " chosen, do you really want to quit?",
                             self.queryQuit2Done, work)
             return
+        outfstab = None
         if (self.output_fstab_str):
-            self.output_fstab = open(self.output_fstab_str, "w")
-            for l in self.fstab_extra:
-                self.output_fstab.write(l)
-                pass
+            outfstab = open(self.output_fstab_str, "w")
             pass
-        for w in work:
-            w.work(self)
-            pass
-        if (self.output_fstab_str):
-            self.output_fstab.close()
+        self.processWork(work, outfstab)
+        if (outfstab):
+            outfstab.close()
             pass
         self.done = True
         return
@@ -3676,14 +3730,7 @@
             pass
         pass
 
-    p = Partitioner(stdscr, output_fstab=output_fstab)
-    e = _add_disks(p, input_fstab)
-    if (e):
-        p.popupWin(e)
-    else:
-        p.refresh()
-        pass
-
+    p = Partitioner(stdscr, input_fstab=input_fstab, output_fstab=output_fstab)
     while (not p.done):
         c = stdscr.getch()
         p.handleChar(CursesKeyMap.keyToStr(c))
