From: Nick Clifton <nickc@redhat.com>
Date: Tue, 26 Feb 2019 19:57:46 +0000
Subject: [PATCH] Import patch to fix PR23919 from the mainline.

	PR binutils/23919
bfd	* bfd.c (bfd_update_compression_header): Explicitly set alignment.
	(bfd_check_compression_header): Add uncompressed_alignment_power
	argument. Check ch_addralign is a power of 2.
	* bfd-in2.h: Regenerated.
	* compress.c (bfd_compress_section_contents): Get and set
	orig_uncompressed_alignment_pow if section is decompressed.
	(bfd_is_section_compressed_with_header): Add and get
	uncompressed_align_pow_p argument.
	(bfd_is_section_compressed): Add uncompressed_align_power argument
	to bfd_is_section_compressed_with_header call.
	(bfd_init_section_decompress_status): Get and set
	uncompressed_alignment_power.
	* elf.c (_bfd_elf_make_section_from_shdr): Add
	uncompressed_align_power argument to
	bfd_is_section_compressed_with_header call.

	* compress.c (bfd_is_section_compressed_with_header): Initialize
	* uncompressed_align_pow_p to 0.

binutils* readelf.c (dump_sections_as_strings): Remove bogus addralign check.
	(dump_sections_as_bytes): Likewise.
	(load_specific_debug_sections): Likewise.
	* testsuite/binutils-all/dw2-3.rS: Adjust alignment.
	* testsuite/binutils-all/dw2-3.rt: Likewise.

gold	* merge.cc (Output_merge_string<Char_type>::do_add_input_section):
	Get addralign from decompressed_section_contents.
	* object.cc (build_compressed_section_map): Set info.addralign.
	(Object::decompressed_section_contents): Add a palign
	argument and store p->second.addralign in *palign if it isn't
	NULL.
	* object.h (Compressed_section_info): Add addralign.
	(section_is_compressed): Add a palign argument, default it
	to NULL, store p->second.addralign in *palign if it isn't NULL.
	(Object::decompressed_section_contents): Likewise.
	* output.cc (Output_section::add_input_section): Get addralign
	from section_is_compressed.


Upstream-Status: Backport [https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=6d33d996167a33552b68c036f1b1571a208ace42]

Signed-off-by: Nick Clifton <nickc@redhat.com>
Signed-off-by: Jagadeesh Krishnanjanappa <jkrishnanjanappa@mvista.com>
---

Reworked bfd/ChangeLog, binutils/ChangeLog, gold/ChangeLog, and 
git/binutils/readelf.c to apply it on binutils v2.29.1.

diff -Naurp git_org/bfd/bfd.c git/bfd/bfd.c
--- git_org/bfd/bfd.c	2019-03-14 22:34:56.136609988 -0700
+++ git/bfd/bfd.c	2019-03-15 00:34:31.692888321 -0700
@@ -2314,6 +2314,8 @@ bfd_update_compression_header (bfd *abfd
 		  bfd_put_32 (abfd, sec->size, &echdr->ch_size);
 		  bfd_put_32 (abfd, 1 << sec->alignment_power,
 			      &echdr->ch_addralign);
+		  /* bfd_log2 (alignof (Elf32_Chdr)).  */
+		  bfd_set_section_alignment (abfd, sec, 2);
 		}
 	      else
 		{
@@ -2324,6 +2326,8 @@ bfd_update_compression_header (bfd *abfd
 		  bfd_put_64 (abfd, sec->size, &echdr->ch_size);
 		  bfd_put_64 (abfd, 1 << sec->alignment_power,
 			      &echdr->ch_addralign);
+		  /* bfd_log2 (alignof (Elf64_Chdr)).  */
+		  bfd_set_section_alignment (abfd, sec, 3);
 		}
 	    }
 	  else
@@ -2336,6 +2340,8 @@ bfd_update_compression_header (bfd *abfd
 		 order.  */
 	      memcpy (contents, "ZLIB", 4);
 	      bfd_putb64 (sec->size, contents + 4);
+	      /* No way to keep the original alignment, just use 1 always.  */
+	      bfd_set_section_alignment (abfd, sec, 0);
 	    }
 	}
     }
@@ -2350,12 +2356,15 @@ bfd_update_compression_header (bfd *abfd
    SYNOPSIS
 	bfd_boolean bfd_check_compression_header
 	  (bfd *abfd, bfd_byte *contents, asection *sec,
-	  bfd_size_type *uncompressed_size);
+          bfd_size_type *uncompressed_size,
+          unsigned int *uncompressed_alignment_power);
+
 
 DESCRIPTION
 	Check the compression header at CONTENTS of SEC in ABFD and
-	store the uncompressed size in UNCOMPRESSED_SIZE if the
-	compression header is valid.
+        store the uncompressed size in UNCOMPRESSED_SIZE and the
+        uncompressed data alignment in UNCOMPRESSED_ALIGNMENT_POWER
+        if the compression header is valid.
 
 RETURNS
 	Return TRUE if the compression header is valid.
@@ -2364,7 +2373,8 @@ RETURNS
 bfd_boolean
 bfd_check_compression_header (bfd *abfd, bfd_byte *contents,
 			      asection *sec,
-			      bfd_size_type *uncompressed_size)
+			      bfd_size_type *uncompressed_size,
+			      unsigned int *uncompressed_alignment_power)
 {
   if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
       && (elf_section_flags (sec) & SHF_COMPRESSED) != 0)
@@ -2386,9 +2396,10 @@ bfd_check_compression_header (bfd *abfd,
 	  chdr.ch_addralign = bfd_get_64 (abfd, &echdr->ch_addralign);
 	}
       if (chdr.ch_type == ELFCOMPRESS_ZLIB
-	  && chdr.ch_addralign == 1U << sec->alignment_power)
+	  && chdr.ch_addralign == (1U << bfd_log2 (chdr.ch_addralign)))
 	{
 	  *uncompressed_size = chdr.ch_size;
+	  *uncompressed_alignment_power = bfd_log2 (chdr.ch_addralign);
 	  return TRUE;
 	}
     }
diff -Naurp git_org/bfd/bfd-in2.h git/bfd/bfd-in2.h
--- git_org/bfd/bfd-in2.h	2019-03-14 22:35:01.000563005 -0700
+++ git/bfd/bfd-in2.h	2019-03-15 00:34:31.691888332 -0700
@@ -7230,7 +7230,8 @@ void bfd_update_compression_header
 
 bfd_boolean bfd_check_compression_header
    (bfd *abfd, bfd_byte *contents, asection *sec,
-    bfd_size_type *uncompressed_size);
+    bfd_size_type *uncompressed_size,
+    unsigned int *uncompressed_alignment_power);
 
 int bfd_get_compression_header_size (bfd *abfd, asection *sec);
 
@@ -7791,7 +7792,8 @@ void bfd_cache_section_contents
 bfd_boolean bfd_is_section_compressed_with_header
    (bfd *abfd, asection *section,
     int *compression_header_size_p,
-    bfd_size_type *uncompressed_size_p);
+    bfd_size_type *uncompressed_size_p,
+    unsigned int *uncompressed_alignment_power_p);
 
 bfd_boolean bfd_is_section_compressed
    (bfd *abfd, asection *section);
diff -Naurp git_org/bfd/ChangeLog git/bfd/ChangeLog
--- git_org/bfd/ChangeLog	2019-03-14 22:35:01.743555828 -0700
+++ git/bfd/ChangeLog	2019-03-15 00:37:57.006661587 -0700
@@ -1,3 +1,31 @@
+2019-02-18  Nick Clifton  <nickc@redhat.com>
+
+	Import from the mainline:
+	2018-11-27  Mark Wielaard  <mark@klomp.org>
+
+	PR binutils/23919
+	* bfd.c (bfd_update_compression_header): Explicitly set alignment.
+	(bfd_check_compression_header): Add uncompressed_alignment_power
+	argument. Check ch_addralign is a power of 2.
+	* bfd-in2.h: Regenerated.
+	* compress.c (bfd_compress_section_contents): Get and set
+	orig_uncompressed_alignment_pow if section is decompressed.
+	(bfd_is_section_compressed_with_header): Add and get
+	uncompressed_align_pow_p argument.
+	(bfd_is_section_compressed): Add uncompressed_align_power argument
+	to bfd_is_section_compressed_with_header call.
+	(bfd_init_section_decompress_status): Get and set
+	uncompressed_alignment_power.
+	* elf.c (_bfd_elf_make_section_from_shdr): Add
+	uncompressed_align_power argument to
+	bfd_is_section_compressed_with_header call.
+
+	2018-11-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR binutils/23919
+	* compress.c (bfd_is_section_compressed_with_header): Initialize
+	* uncompressed_align_pow_p to 0.
+
 2018-02-28  Alan Modra  <amodra@gmail.com>
 
 	PR 22887
diff -Naurp git_org/bfd/compress.c git/bfd/compress.c
--- git_org/bfd/compress.c	2019-03-14 22:34:56.146609891 -0700
+++ git/bfd/compress.c	2019-03-15 00:34:31.692888321 -0700
@@ -84,11 +84,13 @@ bfd_compress_section_contents (bfd *abfd
   int zlib_size = 0;
   int orig_compression_header_size;
   bfd_size_type orig_uncompressed_size;
+  unsigned int orig_uncompressed_alignment_pow;
   int header_size = bfd_get_compression_header_size (abfd, NULL);
   bfd_boolean compressed
     = bfd_is_section_compressed_with_header (abfd, sec,
 					     &orig_compression_header_size,
-					     &orig_uncompressed_size);
+					     &orig_uncompressed_size,
+					     &orig_uncompressed_alignment_pow);
 
   /* Either ELF compression header or the 12-byte, "ZLIB" + 8-byte size,
      overhead in .zdebug* section.  */
@@ -153,6 +155,8 @@ bfd_compress_section_contents (bfd *abfd
 	      return 0;
 	    }
 	  free (uncompressed_buffer);
+	  bfd_set_section_alignment (abfd, sec,
+				     orig_uncompressed_alignment_pow);
 	  sec->contents = buffer;
 	  sec->compress_status = COMPRESS_SECTION_DONE;
 	  return orig_uncompressed_size;
@@ -364,20 +368,25 @@ SYNOPSIS
 	bfd_boolean bfd_is_section_compressed_with_header
 	  (bfd *abfd, asection *section,
 	  int *compression_header_size_p,
-	  bfd_size_type *uncompressed_size_p);
+	  bfd_size_type *uncompressed_size_p,
+	  unsigned int *uncompressed_alignment_power_p);
+
 
 DESCRIPTION
 	Return @code{TRUE} if @var{section} is compressed.  Compression
-	header size is returned in @var{compression_header_size_p} and
-	uncompressed size is returned in @var{uncompressed_size_p}.  If
-	compression is unsupported, compression header size is returned
-	with -1 and uncompressed size is returned with 0.
+	header size is returned in @var{compression_header_size_p},
+        uncompressed size is returned in @var{uncompressed_size_p}
+        and the uncompressed data alignement power is returned in
+        @var{uncompressed_align_pow_p}.  If compression is
+        unsupported, compression header size is returned with -1
+        and uncompressed size is returned with 0.
 */
 
 bfd_boolean
 bfd_is_section_compressed_with_header (bfd *abfd, sec_ptr sec,
 				       int *compression_header_size_p,
-				       bfd_size_type *uncompressed_size_p)
+				       bfd_size_type *uncompressed_size_p,
+				       unsigned int *uncompressed_align_pow_p)
 {
   bfd_byte header[MAX_COMPRESSION_HEADER_SIZE];
   int compression_header_size;
@@ -385,6 +394,8 @@ bfd_is_section_compressed_with_header (b
   unsigned int saved = sec->compress_status;
   bfd_boolean compressed;
 
+  *uncompressed_align_pow_p = 0;
+
   compression_header_size = bfd_get_compression_header_size (abfd, sec);
   if (compression_header_size > MAX_COMPRESSION_HEADER_SIZE)
     abort ();
@@ -412,7 +423,8 @@ bfd_is_section_compressed_with_header (b
       if (compression_header_size != 0)
 	{
 	  if (!bfd_check_compression_header (abfd, header, sec,
-					     uncompressed_size_p))
+					     uncompressed_size_p,
+					     uncompressed_align_pow_p))
 	    compression_header_size = -1;
 	}
       /* Check for the pathalogical case of a debug string section that
@@ -449,9 +461,11 @@ bfd_is_section_compressed (bfd *abfd, se
 {
   int compression_header_size;
   bfd_size_type uncompressed_size;
+  unsigned int uncompressed_align_power;
   return (bfd_is_section_compressed_with_header (abfd, sec,
 						 &compression_header_size,
-						 &uncompressed_size)
+						 &uncompressed_size,
+						 &uncompressed_align_power)
 	  && compression_header_size >= 0
 	  && uncompressed_size > 0);
 }
@@ -480,6 +494,7 @@ bfd_init_section_decompress_status (bfd
   int compression_header_size;
   int header_size;
   bfd_size_type uncompressed_size;
+  unsigned int uncompressed_alignment_power = 0;
 
   compression_header_size = bfd_get_compression_header_size (abfd, sec);
   if (compression_header_size > MAX_COMPRESSION_HEADER_SIZE)
@@ -508,7 +523,8 @@ bfd_init_section_decompress_status (bfd
       uncompressed_size = bfd_getb64 (header + 4);
     }
   else if (!bfd_check_compression_header (abfd, header, sec,
-					 &uncompressed_size))
+					  &uncompressed_size,
+					  &uncompressed_alignment_power))
     {
       bfd_set_error (bfd_error_wrong_format);
       return FALSE;
@@ -516,6 +532,7 @@ bfd_init_section_decompress_status (bfd
 
   sec->compressed_size = sec->size;
   sec->size = uncompressed_size;
+  bfd_set_section_alignment (abfd, sec, uncompressed_alignment_power);
   sec->compress_status = DECOMPRESS_SECTION_SIZED;
 
   return TRUE;
diff -Naurp git_org/bfd/elf.c git/bfd/elf.c
--- git_org/bfd/elf.c	2019-03-14 22:35:02.231551115 -0700
+++ git/bfd/elf.c	2019-03-15 00:34:31.693888310 -0700
@@ -1163,10 +1163,12 @@ _bfd_elf_make_section_from_shdr (bfd *ab
       enum { nothing, compress, decompress } action = nothing;
       int compression_header_size;
       bfd_size_type uncompressed_size;
+      unsigned int uncompressed_align_power;
       bfd_boolean compressed
 	= bfd_is_section_compressed_with_header (abfd, newsect,
 						 &compression_header_size,
-						 &uncompressed_size);
+						 &uncompressed_size,
+						 &uncompressed_align_power);
 
       if (compressed)
 	{
diff -Naurp git_org/binutils/ChangeLog git/binutils/ChangeLog
--- git_org/binutils/ChangeLog	2019-03-14 22:35:01.793555345 -0700
+++ git/binutils/ChangeLog	2019-03-15 00:39:23.386725779 -0700
@@ -1,3 +1,15 @@
+2019-02-18  Nick Clifton  <nickc@redhat.com>
+
+	Import from the mainline:
+	2018-11-27  Mark Wielaard  <mark@klomp.org>
+
+	PR binutils/23919
+	* readelf.c (dump_sections_as_strings): Remove bogus addralign check.
+	(dump_sections_as_bytes): Likewise.
+	(load_specific_debug_sections): Likewise.
+	* testsuite/binutils-all/dw2-3.rS: Adjust alignment.
+	* testsuite/binutils-all/dw2-3.rt: Likewise.
+
 2018-02-01  Alan Modra  <amodra@gmail.com>
 
        PR 22769
diff -Naurp git_org/binutils/readelf.c git/binutils/readelf.c
--- git_org/binutils/readelf.c	2019-03-14 22:35:00.806564879 -0700
+++ git/binutils/readelf.c	2019-03-15 00:44:28.731422439 -0700
@@ -12874,12 +12874,6 @@ dump_section_as_strings (Elf_Internal_Sh
 		    printable_section_name (section), chdr.ch_type);
 	      return FALSE;
 	    }
-	  else if (chdr.ch_addralign != section->sh_addralign)
-	    {
-	      warn (_("compressed section '%s' is corrupted\n"),
-		    printable_section_name (section));
-	      return FALSE;
-	    }
 	  uncompressed_size = chdr.ch_size;
 	  start += compression_header_size;
 	  new_size -= compression_header_size;
@@ -13021,12 +13015,6 @@ dump_section_as_bytes (Elf_Internal_Shdr
 		    printable_section_name (section), chdr.ch_type);
 	      return FALSE;
 	    }
-	  else if (chdr.ch_addralign != section->sh_addralign)
-	    {
-	      warn (_("compressed section '%s' is corrupted\n"),
-		    printable_section_name (section));
-	      return FALSE;
-	    }
 	  uncompressed_size = chdr.ch_size;
 	  start += compression_header_size;
 	  new_size -= compression_header_size;
@@ -13189,12 +13177,6 @@ load_specific_debug_section (enum dwarf_
 		    section->name, chdr.ch_type);
 	      return FALSE;
 	    }
-	  else if (chdr.ch_addralign != sec->sh_addralign)
-	    {
-	      warn (_("compressed section '%s' is corrupted\n"),
-		    section->name);
-	      return FALSE;
-	    }
 	  uncompressed_size = chdr.ch_size;
 	  start += compression_header_size;
 	  size -= compression_header_size;
diff -Naurp git_org/binutils/testsuite/binutils-all/dw2-3.rS git/binutils/testsuite/binutils-all/dw2-3.rS
--- git_org/binutils/testsuite/binutils-all/dw2-3.rS	2019-03-14 22:34:56.306608345 -0700
+++ git/binutils/testsuite/binutils-all/dw2-3.rS	2019-03-15 00:34:31.693888310 -0700
@@ -1,3 +1,3 @@
 #...
- +\[[ 0-9]+\] .debug_info +(PROGBITS|MIPS_DWARF) +0+ +[0-9a-f]+ +[0-9a-f]+ [0-9a-f]+ +C +0 +0 +1
+ +\[[ 0-9]+\] .debug_info +(PROGBITS|MIPS_DWARF) +0+ +[0-9a-f]+ +[0-9a-f]+ [0-9a-f]+ +C +0 +0 +(4|8)
 #pass
diff -Naurp git_org/binutils/testsuite/binutils-all/dw2-3.rt git/binutils/testsuite/binutils-all/dw2-3.rt
--- git_org/binutils/testsuite/binutils-all/dw2-3.rt	2019-03-14 22:34:56.306608345 -0700
+++ git/binutils/testsuite/binutils-all/dw2-3.rt	2019-03-15 00:34:31.693888310 -0700
@@ -1,6 +1,6 @@
 #...
  +\[[ 0-9]+\] .debug_info
- +(PROGBITS|MIPS_DWARF) +0+ +[0-9a-f]+ +[0-9a-f]+ +[0-9a-f]+ +0 +0 +1
+ +(PROGBITS|MIPS_DWARF) +0+ +[0-9a-f]+ +[0-9a-f]+ +[0-9a-f]+ +0 +0 +(4|8)
  +\[0+800\]: COMPRESSED
  +ZLIB, 0+9d, 1
 #pass
diff -Naurp git_org/gold/ChangeLog git/gold/ChangeLog
--- git_org/gold/ChangeLog	2019-03-14 22:34:57.260599130 -0700
+++ git/gold/ChangeLog	2019-03-15 00:40:49.245796199 -0700
@@ -1,3 +1,22 @@
+2019-02-18  Nick Clifton  <nickc@redhat.com>
+
+	Import from the mainline:
+	2018-12-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR binutils/23919
+	* merge.cc (Output_merge_string<Char_type>::do_add_input_section):
+	Get addralign from decompressed_section_contents.
+	* object.cc (build_compressed_section_map): Set info.addralign.
+	(Object::decompressed_section_contents): Add a palign
+	argument and store p->second.addralign in *palign if it isn't
+	NULL.
+	* object.h (Compressed_section_info): Add addralign.
+	(section_is_compressed): Add a palign argument, default it
+	to NULL, store p->second.addralign in *palign if it isn't NULL.
+	(Object::decompressed_section_contents): Likewise.
+	* output.cc (Output_section::add_input_section): Get addralign
+	from section_is_compressed.
+
 2018-04-27  Sriraman Tallam  <tmsriram@google.com>
 
 	Apply from master:
diff -Naurp git_org/gold/merge.cc git/gold/merge.cc
--- git_org/gold/merge.cc	2019-03-14 22:34:57.274598995 -0700
+++ git/gold/merge.cc	2019-03-15 00:34:31.694888299 -0700
@@ -440,9 +440,11 @@ Output_merge_string<Char_type>::do_add_i
 {
   section_size_type sec_len;
   bool is_new;
+  uint64_t addralign = this->addralign();
   const unsigned char* pdata = object->decompressed_section_contents(shndx,
 								     &sec_len,
-								     &is_new);
+								     &is_new,
+								     &addralign);
 
   const Char_type* p = reinterpret_cast<const Char_type*>(pdata);
   const Char_type* pend = p + sec_len / sizeof(Char_type);
@@ -494,7 +496,7 @@ Output_merge_string<Char_type>::do_add_i
   // aligned, so each string within the section must retain the same
   // modulo.
   uintptr_t init_align_modulo = (reinterpret_cast<uintptr_t>(pdata)
-				 & (this->addralign() - 1));
+				 & (addralign - 1));
   bool has_misaligned_strings = false;
 
   while (p < pend)
@@ -503,7 +505,7 @@ Output_merge_string<Char_type>::do_add_i
 
       // Within merge input section each string must be aligned.
       if (len != 0
-	  && ((reinterpret_cast<uintptr_t>(p) & (this->addralign() - 1))
+	  && ((reinterpret_cast<uintptr_t>(p) & (addralign - 1))
 	      != init_align_modulo))
 	  has_misaligned_strings = true;
 
diff -Naurp git_org/gold/object.cc git/gold/object.cc
--- git_org/gold/object.cc	2019-03-14 22:34:57.277598966 -0700
+++ git/gold/object.cc	2019-03-15 00:34:31.695888288 -0700
@@ -752,11 +752,13 @@ build_compressed_section_map(
 	      const unsigned char* contents =
 		  obj->section_contents(i, &len, false);
 	      uint64_t uncompressed_size;
+	      Compressed_section_info info;
 	      if (is_zcompressed)
 		{
 		  // Skip over the ".zdebug" prefix.
 		  name += 7;
 		  uncompressed_size = get_uncompressed_size(contents, len);
+		  info.addralign = shdr.get_sh_addralign();
 		}
 	      else
 		{
@@ -764,8 +766,8 @@ build_compressed_section_map(
 		  name += 6;
 		  elfcpp::Chdr<size, big_endian> chdr(contents);
 		  uncompressed_size = chdr.get_ch_size();
+		  info.addralign = chdr.get_ch_addralign();
 		}
-	      Compressed_section_info info;
 	      info.size = convert_to_section_size_type(uncompressed_size);
 	      info.flag = shdr.get_sh_flags();
 	      info.contents = NULL;
@@ -2888,7 +2890,8 @@ const unsigned char*
 Object::decompressed_section_contents(
     unsigned int shndx,
     section_size_type* plen,
-    bool* is_new)
+    bool* is_new,
+    uint64_t* palign)
 {
   section_size_type buffer_size;
   const unsigned char* buffer = this->do_section_contents(shndx, &buffer_size,
@@ -2915,6 +2918,8 @@ Object::decompressed_section_contents(
     {
       *plen = uncompressed_size;
       *is_new = false;
+      if (palign != NULL)
+	*palign = p->second.addralign;
       return p->second.contents;
     }
 
@@ -2936,6 +2941,8 @@ Object::decompressed_section_contents(
   // once in this pass.
   *plen = uncompressed_size;
   *is_new = true;
+  if (palign != NULL)
+    *palign = p->second.addralign;
   return uncompressed_data;
 }
 
diff -Naurp git_org/gold/object.h git/gold/object.h
--- git_org/gold/object.h	2019-03-14 22:34:57.277598966 -0700
+++ git/gold/object.h	2019-03-15 00:34:31.696888277 -0700
@@ -372,6 +372,7 @@ struct Compressed_section_info
 {
   section_size_type size;
   elfcpp::Elf_Xword flag;
+  uint64_t addralign;
   const unsigned char* contents;
 };
 typedef std::map<unsigned int, Compressed_section_info> Compressed_section_map;
@@ -807,7 +808,8 @@ class Object
 
   bool
   section_is_compressed(unsigned int shndx,
-			section_size_type* uncompressed_size) const
+			section_size_type* uncompressed_size,
+			elfcpp::Elf_Xword* palign = NULL) const
   {
     if (this->compressed_sections_ == NULL)
       return false;
@@ -817,6 +819,8 @@ class Object
       {
 	if (uncompressed_size != NULL)
 	  *uncompressed_size = p->second.size;
+	if (palign != NULL)
+	  *palign = p->second.addralign;
 	return true;
       }
     return false;
@@ -827,7 +831,7 @@ class Object
   // by the caller.
   const unsigned char*
   decompressed_section_contents(unsigned int shndx, section_size_type* plen,
-				bool* is_cached);
+				bool* is_cached, uint64_t* palign = NULL);
 
   // Discard any buffers of decompressed sections.  This is done
   // at the end of the Add_symbols task.
diff -Naurp git_org/gold/output.cc git/gold/output.cc
--- git_org/gold/output.cc	2019-03-14 22:34:57.278598957 -0700
+++ git/gold/output.cc	2019-03-15 00:34:31.696888277 -0700
@@ -2435,7 +2435,14 @@ Output_section::add_input_section(Layout
 				  unsigned int reloc_shndx,
 				  bool have_sections_script)
 {
+  section_size_type input_section_size = shdr.get_sh_size();
+  section_size_type uncompressed_size;
   elfcpp::Elf_Xword addralign = shdr.get_sh_addralign();
+
+  if (object->section_is_compressed(shndx, &uncompressed_size,
+                                   &addralign))
+    input_section_size = uncompressed_size;
+
   if ((addralign & (addralign - 1)) != 0)
     {
       object->error(_("invalid alignment %lu for section \"%s\""),
@@ -2485,11 +2492,6 @@ Output_section::add_input_section(Layout
 	}
     }
 
-  section_size_type input_section_size = shdr.get_sh_size();
-  section_size_type uncompressed_size;
-  if (object->section_is_compressed(shndx, &uncompressed_size))
-    input_section_size = uncompressed_size;
-
   off_t offset_in_section;
 
   if (this->has_fixed_layout())
