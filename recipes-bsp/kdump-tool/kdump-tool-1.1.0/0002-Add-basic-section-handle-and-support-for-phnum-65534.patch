From bafd0f06da51388420e5c412051c78fd2b1d4bed Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Tue, 4 Nov 2014 20:21:17 -0600
Subject: [PATCH 2/2] Add basic section handle and support for phnum > 65534

Add the ability to handle sections, and if the number of phdrs is
more than 65534, use a NULL section to hold the phnum in the sh_info
field, per the specification.
---
 elfc.c |  959 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++-------
 elfc.h |  159 +++++++++++
 2 files changed, 1023 insertions(+), 95 deletions(-)

diff --git a/elfc.c b/elfc.c
index fc4f059..6d2ed2f 100644
--- a/elfc.c
+++ b/elfc.c
@@ -75,6 +75,25 @@ struct elfc_phdr {
 			const void *idata, size_t len, void *userdata);
 };
 
+struct elfc_shdr {
+	GElf_Shdr sh;
+	void *data;
+	void *userdata;
+	void (*data_free)(struct elfc *e, void *data, void *userdata);
+	int (*pre_write)(struct elfc *e, GElf_Shdr *shdr,
+			 void *data, void *userdata);
+	int (*do_write)(struct elfc *e, int fd, GElf_Shdr *shdr,
+			void *data, void *userdata);
+	void (*post_write)(struct elfc *e, GElf_Shdr *shdr,
+			   void *data, void *userdata);
+	int (*get_data)(struct elfc *e, GElf_Shdr *shdr, void *data,
+			GElf_Off off,
+			void *odata, size_t len, void *userdata);
+	int (*set_data)(struct elfc *e, GElf_Shdr *shdr, void *data,
+			GElf_Off off,
+			const void *idata, size_t len, void *userdata);
+};
+
 struct elfc {
 	GElf_Ehdr hdr;
 	int eerrno;
@@ -85,9 +104,17 @@ struct elfc {
 	GElf_Off after_headers;
 
 	struct elfc_phdr *phdrs;
-	int num_phdrs;
+	Elf32_Word num_phdrs;
 	int alloced_phdrs;
 
+	/*
+	 * We only hold a dummy section header for putting the
+	 * num_phdrs values if it is greater than 65534.
+	 */
+	struct elfc_shdr *shdrs;
+	Elf32_Word num_shdrs;
+	int alloced_shdrs;
+
 	struct elfc_note *notes;
 	int num_notes;
 	int alloced_notes;
@@ -209,6 +236,123 @@ elfc_gen_phdr_free(struct elfc *e, void *data, void *userdata)
 		free(userdata);
 }
 
+#define Shdr32_Entries \
+	ShdrE(Word,	name);		\
+	ShdrE(Word,	type);		\
+	ShdrE(Word,	flags);		\
+	ShdrE(Addr,	addr);		\
+	ShdrE(Off,	offset);	\
+	ShdrE(Word,	size);		\
+	ShdrE(Word,	link);		\
+	ShdrE(Word,	info);		\
+	ShdrE(Word,	addralign);	\
+	ShdrE(Word,	entsize);
+
+#define Shdr64_Entries \
+	ShdrE(Word,	name);		\
+	ShdrE(Word,	type);		\
+	ShdrE(Xword,	flags);		\
+	ShdrE(Addr,	addr);		\
+	ShdrE(Off,	offset);	\
+	ShdrE(Xword,	size);		\
+	ShdrE(Word,	link);		\
+	ShdrE(Word,	info);		\
+	ShdrE(Xword,	addralign);	\
+	ShdrE(Xword,	entsize);
+
+static int
+extend_shdrs(struct elfc *e)
+{
+	if (e->num_shdrs == e->alloced_shdrs) {
+		struct elfc_shdr *shdrs;
+
+		shdrs = malloc(sizeof(*shdrs) * (e->alloced_shdrs + 32));
+		if (!shdrs) {
+			e->eerrno = ENOMEM;
+			return -1;
+		}
+		memcpy(shdrs, e->shdrs, sizeof(*shdrs) * e->alloced_shdrs);
+		e->alloced_shdrs += 32;
+		if (e->shdrs)
+			free(e->shdrs);
+		e->shdrs = shdrs;
+	}
+	return 0;
+}
+
+int
+elfc_insert_shdr(struct elfc *e, int pnum,
+		 GElf_Word name, GElf_Word type, GElf_Xword flags,
+		 GElf_Addr addr, GElf_Off offset, GElf_Xword size,
+		 GElf_Word link, GElf_Word info, GElf_Xword addralign,
+		 GElf_Xword entsize)
+{
+	if (pnum > (e->num_shdrs + 1)) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+
+	if (extend_shdrs(e) == -1)
+		return -1;
+
+	memmove(e->shdrs + pnum + 1, e->shdrs + pnum,
+		sizeof(*e->shdrs) * (e->num_shdrs - pnum));
+
+	memset(e->shdrs + pnum, 0, sizeof(*e->shdrs));
+
+#define ShdrE(type, name) e->shdrs[pnum].sh.sh_ ## name = name;
+	Shdr64_Entries;
+#undef ShdrE
+	e->num_shdrs++;
+	return pnum;
+}
+
+int
+elfc_add_shdr(struct elfc *e,
+	      GElf_Word name, GElf_Word type, GElf_Xword flags,
+	      GElf_Addr addr, GElf_Off offset, GElf_Xword size,
+	      GElf_Word link, GElf_Word info, GElf_Xword addralign,
+	      GElf_Xword entsize)
+{
+	int i;
+
+	extend_shdrs(e);
+
+	i = e->num_shdrs;
+	memset(&e->shdrs[i], 0, sizeof(e->shdrs[i]));
+#define ShdrE(type, name) e->shdrs[i].sh.sh_ ## name = name;
+	Shdr64_Entries;
+#undef ShdrE
+	e->num_shdrs++;
+	return i;
+}
+
+int
+elfc_del_shdr(struct elfc *e, int pnum)
+{
+	if (pnum >= e->num_shdrs) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+
+	if (e->shdrs[pnum].data_free)
+		e->shdrs[pnum].data_free(e, e->shdrs[pnum].data,
+					 e->shdrs[pnum].userdata);
+	memmove(e->shdrs + pnum, e->shdrs + pnum + 1,
+		sizeof(*e->shdrs) * (e->num_shdrs - pnum - 1));
+	e->num_shdrs--;
+	return 0;
+}
+
+void
+elfc_gen_shdr_free(struct elfc *e, void *data, void *userdata)
+{
+	if (data)
+		free(data);
+	if (userdata)
+		free(userdata);
+}
+
 int
 elfc_tmpfd(void)
 {
@@ -524,6 +668,396 @@ elfc_set_phdr_offset(struct elfc *e, int pnum, GElf_Off offset)
 	return 0;
 }
 
+int
+elfc_phdr_read(struct elfc *e, int pnum, GElf_Off off,
+	       void *odata, size_t len)
+{
+	int rv;
+
+	if (pnum > (e->num_phdrs + 1)) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+	if (!e->phdrs[pnum].get_data) {
+		e->eerrno = ENOSYS;
+		return -1;
+	}
+	rv = e->phdrs[pnum].get_data(e, &e->phdrs[pnum].p, e->phdrs[pnum].data,
+				     off, odata, len, e->phdrs[pnum].userdata);
+	if (rv)
+		e->eerrno = errno;
+	return rv;
+}
+
+int
+elfc_phdr_write(struct elfc *e, int pnum, GElf_Off off,
+		const void *odata, size_t len)
+{
+	int rv;
+
+	if (pnum > (e->num_phdrs + 1)) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+	if (!e->phdrs[pnum].set_data) {
+		e->eerrno = ENOSYS;
+		return -1;
+	}
+	rv = e->phdrs[pnum].set_data(e, &e->phdrs[pnum].p, e->phdrs[pnum].data,
+				     off, odata, len, e->phdrs[pnum].userdata);
+	if (rv)
+		e->eerrno = errno;
+	return rv;
+}
+
+int
+elfc_phdr_alloc_read(struct elfc *e, int pnum, GElf_Off off,
+		     void **odata, size_t len)
+{
+	int rv;
+	char *buf;
+
+	if (pnum > (e->num_phdrs + 1)) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+	if (!e->phdrs[pnum].get_data) {
+		e->eerrno = ENOSYS;
+		return -1;
+	}
+	buf = malloc(len);
+	if (!buf) {
+		e->eerrno = ENOMEM;
+		return -1;
+	}
+	rv = e->phdrs[pnum].get_data(e, &e->phdrs[pnum].p, e->phdrs[pnum].data,
+				     off, buf, len, e->phdrs[pnum].userdata);
+	if (rv) {
+		free(buf);
+		e->eerrno = errno;
+	} else
+		*odata = buf;
+
+	return rv;
+}
+
+static void *
+elfc_shdr_tmpfile_alloc(struct elfc *e)
+{
+	struct elfc_tmpfile *tf;
+
+	tf = malloc(sizeof(*tf));
+	if (tf)
+		tf->fd = -1;
+	return tf;
+}
+
+/*
+ * Create a copy of the contents in a temparary file.  This way if we
+ * are reading and writing the same file, the data won't be clobbered.
+ */
+static int
+elfc_shdr_tmpfile_pre_write(struct elfc *e, GElf_Shdr *shdr,
+			    void *data, void *userdata)
+{
+	struct elfc_tmpfile *tf = userdata;
+	int fd;
+	int rv;
+
+	tf->fd = elfc_tmpfd();
+	if (tf->fd == -1)
+		return -1;
+
+	fd = elfc_get_fd(e);
+	rv = lseek(fd, shdr->sh_offset, SEEK_SET);
+	if (rv == -1)
+		e->eerrno = errno;
+	rv = elfc_copy_fd_range(tf->fd, fd, shdr->sh_size);
+	if (rv == -1)
+		return -1;
+	return 0;
+}
+
+static int
+elfc_shdr_tmpfile_do_write(struct elfc *e, int fd, GElf_Shdr *shdr,
+			   void *data, void *userdata)
+{
+	struct elfc_tmpfile *tf = userdata;
+	int rv;
+
+	rv = lseek(tf->fd, 0, SEEK_SET);
+	if (rv == -1)
+		return -1;
+
+	rv = elfc_copy_fd_range(fd, tf->fd, shdr->sh_size);
+	if (rv == -1)
+		return -1;
+
+	close(tf->fd);
+	tf->fd = -1;
+	return 0;
+}
+
+static void
+elfc_shdr_tmpfile_post_write(struct elfc *e, GElf_Shdr *shdr,
+			     void *data, void *userdata)
+{
+	struct elfc_tmpfile *tf = userdata;
+
+	if (tf->fd != -1) {
+		close(tf->fd);
+		tf->fd = -1;
+	}
+}
+
+static int
+elfc_shdr_tmpfile_get_data(struct elfc *e, GElf_Shdr *shdr, void *data,
+			   GElf_Off off, void *odata, size_t len,
+			   void *userdata)
+{
+	int rv;
+
+	if ((off > shdr->sh_size) || ((off + len) > shdr->sh_size)) {
+		errno = EINVAL;
+		return -1;
+	}
+	rv = lseek(e->fd, off + shdr->sh_offset, SEEK_SET);
+	if (rv == -1)
+		return -1;
+	rv = read(e->fd, odata, len);
+	if (rv == -1)
+		return -1;
+	if (rv != len) {
+		errno = EINVAL;
+		return -1;
+	}
+	return 0;
+}
+
+static int
+elfc_shdr_tmpfile_set_data(struct elfc *e, GElf_Shdr *shdr, void *data,
+			   GElf_Off off, const void *idata, size_t len,
+			   void *userdata)
+{
+	int rv;
+
+	if ((off > shdr->sh_size) || ((off + len) > shdr->sh_size)) {
+		errno = EINVAL;
+		return -1;
+	}
+	rv = lseek(e->fd, off + shdr->sh_offset, SEEK_SET);
+	if (rv == -1)
+		return -1;
+	rv = write(e->fd, idata, len);
+	if (rv == -1)
+		return -1;
+	if (rv != len) {
+		errno = EINVAL;
+		return -1;
+	}
+	return 0;
+}
+
+static void
+elfc_shdr_tmpfile_free(struct elfc *e, void *data, void *userdata)
+{
+	if (userdata)
+		free(userdata);
+}
+
+int
+elfc_shdr_block_get_data(struct elfc *e, GElf_Shdr *shdr, void *data,
+			 GElf_Off off, void *odata, size_t len,
+			 void *userdata)
+{
+	if ((off > shdr->sh_size) || ((off + len) > shdr->sh_size)) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	memcpy(odata, ((char *) data) + off, len);
+	return 0;
+}
+
+int
+elfc_shdr_block_set_data(struct elfc *e, GElf_Shdr *shdr, void *data,
+			 GElf_Off off, const void *idata, size_t len,
+			 void *userdata)
+{
+	if ((off > shdr->sh_size) || ((off + len) > shdr->sh_size)) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	memcpy(data, ((char *) idata) + off, len);
+	return 0;
+}
+
+int
+elfc_shdr_block_do_write(struct elfc *e, int fd, GElf_Shdr *shdr,
+			 void *data, void *userdata)
+{
+	int rv;
+
+	rv = write(fd, data, shdr->sh_size);
+	if (rv == -1)
+		return -1;
+	if (rv != shdr->sh_size) {
+		errno = EINVAL;
+		return -1;
+	}
+	return 0;
+}
+
+int
+elfc_set_shdr_data(struct elfc *e, int snum, void *data,
+		   void (*free_func)(struct elfc *e, void *data,
+				     void *userdata),
+		   int (*pre_write)(struct elfc *e, GElf_Shdr *shdr,
+				    void *data, void *userdata),
+		   int (*do_write)(struct elfc *e, int fd, GElf_Shdr *shdr,
+				   void *data, void *userdata),
+		   void (*post_write)(struct elfc *e, GElf_Shdr *shdr,
+				      void *data, void *userdata),
+		   int (*get_data)(struct elfc *e, GElf_Shdr *shdr, void *data,
+				   GElf_Off off, void *odata, size_t len,
+				   void *userdata),
+		   int (*set_data)(struct elfc *e, GElf_Shdr *shdr, void *data,
+				   GElf_Off off, const void *idata, size_t len,
+				   void *userdata),
+		   void *userdata)
+{
+	if (snum >= e->num_shdrs) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+
+	if (e->shdrs[snum].data_free)
+		e->shdrs[snum].data_free(e, e->shdrs[snum].data,
+					 e->shdrs[snum].userdata);
+	e->shdrs[snum].data = data;
+	e->shdrs[snum].data_free = free_func;
+	e->shdrs[snum].pre_write = pre_write;
+	e->shdrs[snum].do_write = do_write;
+	e->shdrs[snum].post_write = post_write;
+	e->shdrs[snum].get_data = get_data;
+	e->shdrs[snum].set_data = set_data;
+	e->shdrs[snum].userdata = userdata;
+	return 0;
+}
+
+int
+elfc_get_num_shdrs(struct elfc *e)
+{
+	return e->num_shdrs;
+}
+
+int
+elfc_get_shdr_offset(struct elfc *e, int snum, GElf_Off *off)
+{
+	if (snum >= e->num_shdrs) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+	*off = e->shdrs[snum].sh.sh_offset;
+	return 0;
+}
+
+int
+elfc_get_shdr(struct elfc *e, int snum, GElf_Shdr *hdr)
+{
+	if (snum >= e->num_shdrs) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+	*hdr = e->shdrs[snum].sh;
+	return 0;
+}
+
+int
+elfc_set_shdr_offset(struct elfc *e, int snum, GElf_Off offset)
+{
+	if (snum >= e->num_shdrs) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+	e->shdrs[snum].sh.sh_offset = offset;
+	return 0;
+}
+
+int
+elfc_shdr_read(struct elfc *e, int snum, GElf_Off off,
+	       void *odata, size_t len)
+{
+	int rv;
+
+	if (snum > (e->num_shdrs + 1)) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+	if (!e->shdrs[snum].get_data) {
+		e->eerrno = ENOSYS;
+		return -1;
+	}
+	rv = e->shdrs[snum].get_data(e, &e->shdrs[snum].sh, e->shdrs[snum].data,
+				     off, odata, len, e->shdrs[snum].userdata);
+	if (rv)
+		e->eerrno = errno;
+	return rv;
+}
+
+int
+elfc_shdr_write(struct elfc *e, int snum, GElf_Off off,
+		const void *odata, size_t len)
+{
+	int rv;
+
+	if (snum > (e->num_shdrs + 1)) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+	if (!e->shdrs[snum].set_data) {
+		e->eerrno = ENOSYS;
+		return -1;
+	}
+	rv = e->shdrs[snum].set_data(e, &e->shdrs[snum].sh, e->shdrs[snum].data,
+				     off, odata, len, e->shdrs[snum].userdata);
+	if (rv)
+		e->eerrno = errno;
+	return rv;
+}
+
+int
+elfc_shdr_alloc_read(struct elfc *e, int snum, GElf_Off off,
+		     void **odata, size_t len)
+{
+	int rv;
+	char *buf;
+
+	if (snum > (e->num_shdrs + 1)) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+	if (!e->shdrs[snum].get_data) {
+		e->eerrno = ENOSYS;
+		return -1;
+	}
+	buf = malloc(len);
+	if (!buf) {
+		e->eerrno = ENOMEM;
+		return -1;
+	}
+	rv = e->shdrs[snum].get_data(e, &e->shdrs[snum].sh, e->shdrs[snum].data,
+				     off, buf, len, e->phdrs[snum].userdata);
+	if (rv) {
+		free(buf);
+		e->eerrno = errno;
+	} else
+		*odata = buf;
+
+	return rv;
+}
+
 static int
 elfc_add_note_nocheck(struct elfc *e, Elf32_Word type,
 		      const char *name, int namelen,
@@ -767,79 +1301,6 @@ elfc_alloc_read_data(struct elfc *e, GElf_Off off, void **odata, size_t len)
 	return rv;
 }
 
-int
-elfc_phdr_read(struct elfc *e, int pnum, GElf_Off off,
-	       void *odata, size_t len)
-{
-	int rv;
-
-	if (pnum > (e->num_phdrs + 1)) {
-		e->eerrno = EINVAL;
-		return -1;
-	}
-	if (!e->phdrs[pnum].get_data) {
-		e->eerrno = ENOSYS;
-		return -1;
-	}
-	rv = e->phdrs[pnum].get_data(e, &e->phdrs[pnum].p, e->phdrs[pnum].data,
-				     off, odata, len, e->phdrs[pnum].userdata);
-	if (rv)
-		e->eerrno = errno;
-	return rv;
-}
-
-int
-elfc_phdr_write(struct elfc *e, int pnum, GElf_Off off,
-		const void *odata, size_t len)
-{
-	int rv;
-
-	if (pnum > (e->num_phdrs + 1)) {
-		e->eerrno = EINVAL;
-		return -1;
-	}
-	if (!e->phdrs[pnum].set_data) {
-		e->eerrno = ENOSYS;
-		return -1;
-	}
-	rv = e->phdrs[pnum].set_data(e, &e->phdrs[pnum].p, e->phdrs[pnum].data,
-				     off, odata, len, e->phdrs[pnum].userdata);
-	if (rv)
-		e->eerrno = errno;
-	return rv;
-}
-
-int
-elfc_phdr_alloc_read(struct elfc *e, int pnum, GElf_Off off,
-		     void **odata, size_t len)
-{
-	int rv;
-	char *buf;
-
-	if (pnum > (e->num_phdrs + 1)) {
-		e->eerrno = EINVAL;
-		return -1;
-	}
-	if (!e->phdrs[pnum].get_data) {
-		e->eerrno = ENOSYS;
-		return -1;
-	}
-	buf = malloc(len);
-	if (!buf) {
-		e->eerrno = ENOMEM;
-		return -1;
-	}
-	rv = e->phdrs[pnum].get_data(e, &e->phdrs[pnum].p, e->phdrs[pnum].data,
-				     off, buf, len, e->phdrs[pnum].userdata);
-	if (rv) {
-		free(buf);
-		e->eerrno = errno;
-	} else
-		*odata = buf;
-
-	return rv;
-}
-
 GElf_Off
 elfc_file_size(struct elfc *e)
 {
@@ -1525,12 +1986,12 @@ elfc_write_phdrs(struct elfc *e)
 }
 
 static int
-read_elf32_phdrs(struct elfc *e, char *buf)
+read_elf32_phdrs(struct elfc *e, char *buf, GElf_Word phnum)
 {
 	int i;
 	struct elfc_phdr *phdrs;
 
-	phdrs = malloc(sizeof(*phdrs) * e->hdr.e_phnum);
+	phdrs = malloc(sizeof(*phdrs) * phnum);
 	if (!phdrs) {
 		e->eerrno = ENOMEM;
 		return -1;
@@ -1539,8 +2000,8 @@ read_elf32_phdrs(struct elfc *e, char *buf)
 	if (e->phdrs) {
 		free(e->phdrs);
 	}
-	e->num_phdrs = e->hdr.e_phnum;
-	e->alloced_phdrs = e->hdr.e_phnum;
+	e->num_phdrs = phnum;
+	e->alloced_phdrs = phnum;
 	e->phdrs = phdrs;
 
 	for (i = 0; i < e->num_phdrs; i++) {
@@ -1556,12 +2017,12 @@ read_elf32_phdrs(struct elfc *e, char *buf)
 }
 
 static int
-read_elf64_phdrs(struct elfc *e, char *buf)
+read_elf64_phdrs(struct elfc *e, char *buf, GElf_Word phnum)
 {
 	int i;
 	struct elfc_phdr *phdrs;
 
-	phdrs = malloc(sizeof(*phdrs) * e->hdr.e_phnum);
+	phdrs = malloc(sizeof(*phdrs) * phnum);
 	if (!phdrs) {
 		e->eerrno = ENOMEM;
 		return -1;
@@ -1570,8 +2031,8 @@ read_elf64_phdrs(struct elfc *e, char *buf)
 	if (e->phdrs) {
 		free(e->phdrs);
 	}
-	e->num_phdrs = e->hdr.e_phnum;
-	e->alloced_phdrs = e->hdr.e_phnum;
+	e->num_phdrs = phnum;
+	e->alloced_phdrs = phnum;
 	e->phdrs = phdrs;
 
 	for (i = 0; i < e->num_phdrs; i++) {
@@ -1587,21 +2048,43 @@ read_elf64_phdrs(struct elfc *e, char *buf)
 	return 0;
 }
 
+static int get_phnum(struct elfc *e, GElf_Word *r_phnum)
+{
+	GElf_Word phnum = e->hdr.e_phnum;
+
+	if (phnum == PN_XNUM) {
+		/* It's in section 0 sh_info field. */
+		if (e->hdr.e_shnum == 0) {
+			e->eerrno = EINVAL;
+			return -1;
+		}
+		phnum = e->shdrs[0].sh.sh_info;
+	}
+
+	*r_phnum = phnum;
+	return 0;
+}
+
 static int
 elfc_read_phdrs(struct elfc *e)
 {
 	void *buf;
 	int rv;
+	GElf_Word phnum;
+
+	rv = get_phnum(e, &phnum);
+	if (rv == -1)
+		return -1;
 
 	rv = elfc_alloc_read_data(e, e->hdr.e_phoff, &buf,
-				  e->hdr.e_phentsize * e->hdr.e_phnum);
+				  e->hdr.e_phentsize * phnum);
 	if (rv == -1)
 		return -1;
 
 	if (e->hdr.e_ident[EI_CLASS] == ELFCLASS32)
-		rv = read_elf32_phdrs(e, buf);
+		rv = read_elf32_phdrs(e, buf, phnum);
 	else
-		rv = read_elf64_phdrs(e, buf);
+		rv = read_elf64_phdrs(e, buf, phnum);
 	free(buf);
 	if (rv != -1) {
 		int i;
@@ -1623,6 +2106,196 @@ elfc_read_phdrs(struct elfc *e)
 	return rv;
 }
 
+static void
+free_shdrs(struct elfc *e)
+{
+	int i;
+
+	if (!e->shdrs)
+		return;
+	for (i = 0; i < e->num_shdrs; i++) {
+		if (e->shdrs[i].data_free)
+			e->shdrs[i].data_free(e, e->shdrs[i].data,
+					      e->shdrs[i].userdata);
+	}
+	free(e->shdrs);
+	e->shdrs = NULL;
+	e->num_shdrs = 0;
+	e->alloced_shdrs = 0;
+}
+
+static int
+write_elf32_shdrs(struct elfc *e)
+{
+	int i;
+	int rv;
+	Elf32_Shdr *p32;
+	size_t l = sizeof(*p32) * e->num_shdrs;
+
+	p32 = malloc(l);
+	if (!p32) {
+		e->eerrno = ENOMEM;
+		return -1;
+	}
+	for (i = 0; i < e->num_shdrs; i++) {
+#define ShdrE(type, name) p32[i].sh_ ## name = \
+	elfc_put ## type(e, e->shdrs[i].sh.sh_ ## name)
+		Shdr32_Entries;
+#undef ShdrE
+	}
+	rv = write(e->fd, p32, l);
+	free(p32);
+	if (rv == -1) {
+		e->eerrno = errno;
+		return -1;
+	}
+	if (rv != l) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+	return 0;
+}
+
+static int
+write_elf64_shdrs(struct elfc *e)
+{
+	int i;
+	int rv;
+	Elf64_Shdr *p64;
+	size_t l = sizeof(*p64) * e->num_shdrs;
+
+	p64 = malloc(l);
+	if (!p64) {
+		e->eerrno = ENOMEM;
+		return -1;
+	}
+	for (i = 0; i < e->num_shdrs; i++) {
+#define ShdrE(type, name) p64[i].sh_ ## name = \
+	elfc_put ## type(e, e->shdrs[i].sh.sh_ ## name)
+		Shdr64_Entries;
+#undef ShdrE
+	}
+	rv = write(e->fd, p64, l);
+	free(p64);
+	if (rv == -1) {
+		e->eerrno = errno;
+		return -1;
+	}
+	if (rv != l) {
+		e->eerrno = EINVAL;
+		return -1;
+	}
+	return 0;
+}
+
+static int
+elfc_write_shdrs(struct elfc *e)
+{
+	if (e->hdr.e_ident[EI_CLASS] == ELFCLASS32)
+		return write_elf32_shdrs(e);
+	else
+		return write_elf64_shdrs(e);
+}
+
+static int
+read_elf32_shdrs(struct elfc *e, char *buf)
+{
+	int i;
+	struct elfc_shdr *shdrs;
+
+	shdrs = malloc(sizeof(*shdrs) * e->hdr.e_shnum);
+	if (!shdrs) {
+		e->eerrno = ENOMEM;
+		return -1;
+	}
+
+	if (e->shdrs) {
+		free(e->shdrs);
+	}
+	e->num_shdrs = e->hdr.e_shnum;
+	e->alloced_shdrs = e->hdr.e_shnum;
+	e->shdrs = shdrs;
+
+	for (i = 0; i < e->num_shdrs; i++) {
+		Elf32_Shdr *p32 = ((Elf32_Shdr *)
+				   (buf + (i * e->hdr.e_shentsize)));;
+#define ShdrE(type, name) e->shdrs[i].sh.sh_ ## name = \
+	elfc_get ## type(e, p32->sh_ ## name)
+		Shdr32_Entries;
+#undef ShdrE
+	}
+
+	return 0;
+}
+
+static int
+read_elf64_shdrs(struct elfc *e, char *buf)
+{
+	int i;
+	struct elfc_shdr *shdrs;
+
+	shdrs = malloc(sizeof(*shdrs) * e->hdr.e_shnum);
+	if (!shdrs) {
+		e->eerrno = ENOMEM;
+		return -1;
+	}
+
+	if (e->shdrs) {
+		free(e->shdrs);
+	}
+	e->num_shdrs = e->hdr.e_shnum;
+	e->alloced_shdrs = e->hdr.e_shnum;
+	e->shdrs = shdrs;
+
+	for (i = 0; i < e->num_shdrs; i++) {
+		Elf64_Shdr *p64 = ((Elf64_Shdr *)
+				   (buf + (i * e->hdr.e_phentsize)));
+
+#define ShdrE(type, name) e->shdrs[i].sh.sh_ ## name = \
+	elfc_get ## type(e, p64->sh_ ## name)
+		Shdr64_Entries;
+#undef ShdrE
+	}
+
+	return 0;
+}
+
+static int
+elfc_read_shdrs(struct elfc *e)
+{
+	void *buf;
+	int rv;
+
+	rv = elfc_alloc_read_data(e, e->hdr.e_phoff, &buf,
+				  e->hdr.e_shentsize * e->hdr.e_shnum);
+	if (rv == -1)
+		return -1;
+
+	if (e->hdr.e_ident[EI_CLASS] == ELFCLASS32)
+		rv = read_elf32_shdrs(e, buf);
+	else
+		rv = read_elf64_shdrs(e, buf);
+	free(buf);
+	if (rv != -1) {
+		int i;
+
+		for (i = 0; i < e->num_shdrs; i++) {
+			e->shdrs[i].userdata = elfc_shdr_tmpfile_alloc(e);
+			if (!e->shdrs[i].userdata) {
+				e->eerrno = ENOMEM;
+				return -1;
+			}
+			e->shdrs[i].pre_write = elfc_shdr_tmpfile_pre_write;
+			e->shdrs[i].do_write = elfc_shdr_tmpfile_do_write;
+			e->shdrs[i].post_write = elfc_shdr_tmpfile_post_write;
+			e->shdrs[i].data_free = elfc_shdr_tmpfile_free;
+			e->shdrs[i].get_data = elfc_shdr_tmpfile_get_data;
+			e->shdrs[i].set_data = elfc_shdr_tmpfile_set_data;
+		}
+	}
+	return rv;
+}
+
 struct elfc *
 elfc_alloc(void)
 {
@@ -1665,6 +2338,7 @@ elfc_setup(struct elfc *e, GElf_Half type)
 static void
 elfc_freei(struct elfc *e)
 {
+	free_shdrs(e);
 	free_phdrs(e);
 	free_notes(e);
 }
@@ -1679,13 +2353,22 @@ elfc_free(struct elfc *e)
 static int
 validate_elf_header(struct elfc *e)
 {
+	GElf_Word phnum;
+
 	if (e->hdr.e_phoff < e->hdr.e_ehsize)
 		return -1;
 	if (e->hdr.e_phentsize < elfc_phdr_size_one(e))
 		return -1;
+	if (e->hdr.e_shoff && e->hdr.e_shoff < e->hdr.e_ehsize)
+		return -1;
+	if (e->hdr.e_shoff && e->hdr.e_shentsize < elfc_shdr_size_one(e))
+		return -1;
+	if (get_phnum(e, &phnum) == -1)
+		return -1;
 
 	e->after_headers = e->hdr.e_phoff +
-		(e->hdr.e_phentsize * e->hdr.e_phnum);
+		(e->hdr.e_phentsize * phnum) +
+		(e->hdr.e_shentsize * e->hdr.e_shnum);
 	return 0;
 }
 
@@ -1760,6 +2443,10 @@ elfc_open(struct elfc *e, int fd)
 		goto out;
 	}
 
+	rv = elfc_read_shdrs(e);
+	if (rv == -1)
+		goto out;
+
 	rv = elfc_read_phdrs(e);
 out:
 	return rv;
@@ -1775,6 +2462,26 @@ elfc_ehdr_size(struct elfc *e)
 }
 
 GElf_Off
+elfc_shdr_size_one(struct elfc *e)
+{
+	if (e->hdr.e_ident[EI_CLASS] == ELFCLASS32)
+		return sizeof(Elf32_Shdr);
+	else
+		return sizeof(Elf64_Shdr);
+}
+
+GElf_Off
+elfc_shdr_size(struct elfc *e)
+{
+	GElf_Off size;
+	size = elfc_shdr_size_one(e) * e->hdr.e_shnum;
+	if ((e->num_phdrs > 65534) &&
+	    ((e->hdr.e_shnum == 0) || (e->shdrs[0].sh.sh_type != SHT_NULL)))
+		size += elfc_shdr_size_one(e);
+	return size;
+}
+
+GElf_Off
 elfc_phdr_size_one(struct elfc *e)
 {
 	if (e->hdr.e_ident[EI_CLASS] == ELFCLASS32)
@@ -1787,7 +2494,10 @@ GElf_Off
 elfc_phdr_size(struct elfc *e)
 {
 	GElf_Off size;
-	size = elfc_phdr_size_one(e) * e->hdr.e_phnum;
+	GElf_Word phnum = 0;
+
+	get_phnum(e, &phnum);
+	size = elfc_phdr_size_one(e) * phnum;
 	if (e->notes)
 		size += elfc_phdr_size_one(e);
 	return size;
@@ -1827,7 +2537,7 @@ elfc_notes_size(struct elfc *e)
 GElf_Off
 elfc_headers_size(struct elfc *e)
 {
-	return elfc_ehdr_size(e) + elfc_phdr_size(e);
+	return elfc_ehdr_size(e) + elfc_phdr_size(e) + elfc_shdr_size(e);
 }
 
 GElf_Off
@@ -1845,6 +2555,15 @@ call_phdr_post_write(struct elfc *e, int i)
 				       e->phdrs[i].userdata);
 }
 
+static void
+call_shdr_post_write(struct elfc *e, int i)
+{
+	if (e->shdrs[i].post_write)
+		e->shdrs[i].post_write(e, &e->shdrs[i].sh,
+				       e->shdrs[i].data,
+				       e->shdrs[i].userdata);
+}
+
 int
 elfc_write(struct elfc *e)
 {
@@ -1883,14 +2602,40 @@ elfc_write(struct elfc *e)
 		free_notes(e);
 	}
 
-	e->hdr.e_ehsize = elfc_ehdr_size(e);
-	e->hdr.e_phoff = e->hdr.e_ehsize;
-	if (e->num_phdrs > 65535) {
-		/* FIXME */
-		return -1;
+	off = elfc_ehdr_size(e);
+	e->hdr.e_ehsize = off;
+	if (e->num_phdrs > 65534) {
+		e->hdr.e_phnum = PN_XNUM;
+		/*
+		 * We use a dummy NULL section header in section 0 to
+		 * hold the number of entries in sh_info.
+		 */
+		if ((e->hdr.e_shnum == 0)
+		    || (e->shdrs[0].sh.sh_type != SHT_NULL)) {
+			rv = elfc_insert_shdr(e, 0, SHN_UNDEF, SHT_NULL,
+					      0, 0, 0, 0,
+					      0, e->num_phdrs, 0, 0);
+			if (rv == -1)
+				return rv;
+		} else {
+			e->shdrs[0].sh.sh_info = e->num_phdrs;
+		}
+	} else {
+		e->hdr.e_phnum = e->num_phdrs;
+	}
+
+	e->hdr.e_shnum = e->num_shdrs;
+	if (e->hdr.e_shnum) {
+		e->hdr.e_shentsize = elfc_shdr_size_one(e);
+		e->hdr.e_shoff = off;
+		off += elfc_shdr_size(e);
+	}
+
+	if (e->num_phdrs) {
+		e->hdr.e_phoff = off;
+		e->hdr.e_phentsize = elfc_phdr_size_one(e);
+		off += elfc_phdr_size(e);
 	}
-	e->hdr.e_phnum = e->num_phdrs;
-	e->hdr.e_phentsize = elfc_phdr_size_one(e);
 
 	/* Ignore errors here, it will fail on stdin. */
 	(void) lseek(e->fd, 0, SEEK_SET);
@@ -1903,11 +2648,31 @@ elfc_write(struct elfc *e)
 		return -1;
 
 	off = elfc_headers_size(e);
+	for (i = 0; i < e->num_shdrs; i++) {
+		e->shdrs[i].sh.sh_offset = off;
+		off += e->shdrs[i].sh.sh_size;
+	}
+
 	for (i = 0; i < e->num_phdrs; i++) {
 		e->phdrs[i].p.p_offset = off;
 		off += e->phdrs[i].p.p_filesz;
 	}
 
+	for (i = 0; i < e->num_shdrs; i++) {
+		if (e->shdrs[i].pre_write) {
+			rv = e->shdrs[i].pre_write(e, &e->shdrs[i].sh,
+						   e->shdrs[i].data,
+						   e->shdrs[i].userdata);
+			if (rv == -1) {
+				e->eerrno = errno;
+				i--;
+				for (; i > 0; i--)
+					call_shdr_post_write(e, i);
+				goto out;
+			}
+		}					
+	}
+
 	for (i = 0; i < e->num_phdrs; i++) {
 		if (e->phdrs[i].pre_write) {
 			rv = e->phdrs[i].pre_write(e, &e->phdrs[i].p,
@@ -1923,6 +2688,10 @@ elfc_write(struct elfc *e)
 		}					
 	}
 
+	rv = elfc_write_shdrs(e);
+	if (rv == -1)
+		goto out;
+
 	rv = elfc_write_phdrs(e);
 	if (rv == -1)
 		goto out;
diff --git a/elfc.h b/elfc.h
index c1fd946..43cbbd9 100644
--- a/elfc.h
+++ b/elfc.h
@@ -280,6 +280,165 @@ int elfc_phdr_write(struct elfc *e, int pnum, GElf_Off off,
 int elfc_get_num_phdrs(struct elfc *e);
 
 /*
+ * Return the size of a single Elf Shdr for the file.
+ */
+GElf_Off elfc_shdr_size_one(struct elfc *e);
+
+/*
+ * Return the size of all the defines Elf Shdrs for the file.
+ */
+GElf_Off elfc_shdr_size(struct elfc *e);
+
+
+/*
+ * Add a Shdr to the shdr list for the ELF object.
+ * Returns -1 on error, use elfc_get_errno() to get the errno.
+ * Otherwise returns the index of the new shdr.  Note that these
+ * indexes can change with later processing (especially writing)
+ * so don't assume they stay the same if you have processed the
+ * object in other ways.
+ */
+int elfc_add_shdr(struct elfc *e,
+		  GElf_Word name, GElf_Word type, GElf_Xword flags,
+		  GElf_Addr addr, GElf_Off offset, GElf_Xword size,
+		  GElf_Word link, GElf_Word info, GElf_Xword addralign,
+		  GElf_Xword entsize);
+  
+/*
+ * Like elfc_add_shdr(), but inserts the shdr at the given pnum.
+ */
+int elfc_insert_shdr(struct elfc *e, int pnum,
+		     GElf_Word name, GElf_Word type, GElf_Xword flags,
+		     GElf_Addr addr, GElf_Off offset, GElf_Xword size,
+		     GElf_Word link, GElf_Word info, GElf_Xword addralign,
+		     GElf_Xword entsize);
+
+/*
+ * Delete the given Shdr from the file.  All the header numbers
+ * after it will be decremented by one.
+ * Returns -1 on error, use elfc_get_errno() to get the errno.
+ */
+int elfc_del_shdr(struct elfc *e, int pnum);
+
+/*
+ * Set the data handling for the shdr.  This lets you handle the
+ * processing of data as it goes out to be written.  You can pass
+ * in a data (which is assumed to be a pointer to the actual data)
+ * and userdata (which is assumed to be helper data).  Those are
+ * not required, though, you can use those for whatever you like.
+ * They will just be passed into the given function pointers.
+ *
+ * The free_func() is called whenever the shdr is destroyed,
+ * this is so you can free any data, close file descriptors, etc.
+ *
+ * The pre_write is called after the Shdrs are processed to find the
+ * offsets but before they are written.  The file will not be modified
+ * at this time.  This can be used to store off old data, modify the
+ * offsets, etc.  You can modify the shdrs at this point, since they
+ * are not written yet.
+ * 
+ * The do_write function should perform the output to the given fd.  The
+ * fd will be at the p_offset of the shdr, so you don't have to seek
+ * before writing.
+ *
+ * The post_write function is called after the processing is complete.
+ * If the pre_write function is called, the post_write function will
+ * be called, even if an error occurs.  This way you can clean things
+ * up reliably.
+ *
+ * The get_data function is called if something is trying to fetch
+ * data from the section.  The return results go in odata, so be careful
+ * about that, don't use "data".
+ *
+ * The set_data function is called if something is trying to write
+ * data to the section.  The output data comes from idata, so be careful
+ * about that.
+ *
+ * If these functions are NULL, they will not be called.  All these
+ * functions should return -1 on error, 0 on success, and set errno
+ * on an error.
+
+ * On the headers read in from a file, these functions are
+ * automatically set to functions that will save off the old data to a
+ * temporary file (pre write), and write the data back into the main
+ * file (for do write).
+ *
+ * elfc_shdr_block_do_write() and elfc_gen_shdr_free() are convenience
+ * functions that let you provide a block of data in "data" that is
+ * malloced.  That block will be written out.  The size of the block
+ * is set by shdr->p_filesz, and the free function will free it.
+ *
+ * Returns -1 on error, use elfc_get_errno() to get the errno.
+ */
+int elfc_set_shdr_data(struct elfc *e, int pnum, void *data,
+		       void (*free_func)(struct elfc *e, void *data,
+					 void *userdata),
+		       int (*pre_write)(struct elfc *e, GElf_Shdr *shdr,
+					void *data, void *userdata),
+		       int (*do_write)(struct elfc *e, int fd, GElf_Shdr *shdr,
+				       void *data, void *userdata),
+		       void (*post_write)(struct elfc *e, GElf_Shdr *shdr,
+					  void *data, void *userdata),
+		       int (*get_data)(struct elfc *e, GElf_Shdr *shdr,
+				       void *data,
+				       GElf_Off off, void *idata, size_t len,
+				       void *userdata),
+		       int (*set_data)(struct elfc *e, GElf_Shdr *shdr,
+				       void *data, GElf_Off off,
+				       const void *idata, size_t len,
+				       void *userdata),
+		       void *userdata);
+
+/*
+ * Convenience functions for elfc_set_shdr_data().  Pass in the free
+ * function for free_func and the do_write function for do_write.  See
+ * elfc_set_shdr_data() for more details on this.
+ *
+ * The free func will free data and userdata if not NULL.
+ */
+void elfc_gen_shdr_free(struct elfc *e, void *data, void *userdata);
+int elfc_shdr_block_do_write(struct elfc *e, int fd, GElf_Shdr *shdr,
+			     void *data, void *userdata);
+int elfc_shdr_block_get_data(struct elfc *e, GElf_Shdr *shdr, void *data,
+			     GElf_Off off, void *odata, size_t len,
+			     void *userdata);
+int elfc_shdr_block_set_data(struct elfc *e, GElf_Shdr *shdr, void *data,
+			     GElf_Off off, const void *idata, size_t len,
+			     void *userdata);
+
+/*
+ * Get a copy of an actual shdr. 
+ * Returns -1 on error, use elfc_get_errno() to get the errno.
+ */
+int elfc_get_shdr(struct elfc *e, int pnum, GElf_Shdr *hdr);
+
+/*
+ * Get/set the p_offset value for a shdr.
+ * Returns -1 on error, use elfc_get_errno() to get the errno.
+ */
+int elfc_get_shdr_offset(struct elfc *e, int pnum, GElf_Off *off);
+int elfc_set_shdr_offset(struct elfc *e, int pnum, GElf_Off offset);
+
+/*
+ * Read from the given offset in the program section pnum.
+ * Returns -1 on error, use elfc_get_errno() to get the errno.
+ */
+int elfc_shdr_read(struct elfc *e, int pnum, GElf_Off off,
+		   void *odata, size_t len);
+
+/*
+ * Write to the given offset in the program section pnum.
+ * Returns -1 on error, use elfc_get_errno() to get the errno.
+ */
+int elfc_shdr_write(struct elfc *e, int pnum, GElf_Off off,
+		    const void *odata, size_t len);
+  
+/*
+ * Return the number of shdrs in the ELF object.
+ */
+int elfc_get_num_shdrs(struct elfc *e);
+
+/*
  * Add an ELF note to the object.
  * Returns -1 on error, use elfc_get_errno() to get the errno.
  */
-- 
1.7.9.5

